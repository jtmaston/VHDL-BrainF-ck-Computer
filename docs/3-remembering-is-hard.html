<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-01-05T03:27:27.731179"><title>Decoding memories is hard! | BrainFck Computer</title><script type="application/json" id="virtual-toc-data">[{"id":"architecture","level":0,"title":"Architecture","anchor":"#architecture"},{"id":"decoder","level":0,"title":"Decoder","anchor":"#decoder"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Decoding memories is hard! | BrainFck Computer"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="BrainFck Computer Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//0.1/3-remembering-is-hard.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Decoding memories is hard! | BrainFck Computer"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//0.1/3-remembering-is-hard.html#webpage",
    "url": "writerside-documentation//0.1/3-remembering-is-hard.html",
    "name": "Decoding memories is hard! | BrainFck Computer",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "BrainFck Computer Help"
}</script><!-- End Schema.org --></head><body data-id="3-Remembering-is-hard" data-main-title="Decoding memories is hard!" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Memory"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>BrainFck Computer 0.1 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="3-Remembering-is-hard" id="3-Remembering-is-hard.md">Decoding memories is hard!</h1><section class="chapter"><h2 id="architecture" data-toc="architecture">Architecture</h2><p id="rdsp4l_5">For both RAM and ROM, I've devised a system. Basically, a memory module is formed of two main components:</p><ol class="list _decimal" id="rdsp4l_6" type="1"><li class="list__item" id="rdsp4l_7"><p>An address decoder / cell router: a component that takes an address (an 8-bit value) and breaks it down into individual lines, which act as chip select lines for the...</p></li><li class="list__item" id="rdsp4l_8"><p>Memory cells: these represent individual 8-bit wide cells, that can be either read-write (in the case of RAM), or readonly. This means that the memory architecture will be composed of: </p><ol class="list _decimal" id="rdsp4l_9" type="1"><li class="list__item" id="rdsp4l_10"><p>An 8-bit address bus (I use an integer for easier routing into the decoder)</p></li><li class="list__item" id="rdsp4l_11"><p>An 256-bit wide selector bus (the maximum number of cells that can fit in the 8 bit bus)</p></li><li class="list__item" id="rdsp4l_12"><p>An 8-bit data bus (still debating whether to also convert this into an integer, currently represented as a bus)</p></li><li class="list__item" id="rdsp4l_13"><p>A 'transaction' signal, that tells the memory block when to execute a command</p></li><li class="list__item" id="rdsp4l_14"><p>An enable signal, in order to be able to release the data lines (i.e. so we can attach multiple memory units onto the same bus)</p></li></ol></li></ol></section><section class="chapter"><h2 id="decoder" data-toc="decoder">Decoder</h2><p id="rdsp4l_15">As for the decoder, this seems like the easy part. A simple shift register should do, just to yoink the data on a clock pulse? Well, not quite. I'm still trying to wrap my head around it, but, briefly, here's the deal: I went for a time-based approach. Everything in this design should be clocked, each pulse (i.e. transition from high to low) being a time quanta. We can therefore describe the &quot;performance&quot; of each element in terms of &quot;time quantas&quot; (aka TQ's).</p><p id="rdsp4l_16">The first design was a one-TQ one, one that, as soon as it received a pulse, it shifted the data onto the lines. Well... then I hit a snag:</p><figure id="rdsp4l_17"><img alt="Decoder1TQ.png" src="images/Decoder1TQ.png" title="Decoder1TQ.png" width="1746" height="766"></figure><p id="rdsp4l_18">The answer lies in... signal propagation. You simply cannot shift data onto a bus, then process it, on the same TQ. So, I fixed it by extending the decoder to run on 2 TQ's...</p><figure id="rdsp4l_19"><img alt="Decoder2TQ.png" src="images/Decoder2TQ.png" title="Decoder2TQ.png" width="1798" height="768"></figure><p id="rdsp4l_20">Well, well! This looks better, but... Interestingly, it seems that... It's skipping the odd numbers? It was at this point that I started testing using testbenches (up until now I had loaded the signal into ModelSIM and generated the signals manualy (smart, I know)), and started to notice... the approach was more than flawed... it was dangerously so.</p><p id="rdsp4l_21">I realized I would need a new system. Especially when loading RAM (which supports both read and write), I'd run into a limit: number of edges of a pulse. If I were to, say, set the address decoder on the rising edge, then have the ram return the data on the falling edge, it would work:</p><div class="table-wrapper"><table class="wide" id="rdsp4l_22"><thead><tr class="ijRowHead" id="rdsp4l_30"><th id="rdsp4l_32"><p>TQ 1</p></th><th id="rdsp4l_33"><p>TQ 2</p></th></tr></thead><tbody><tr id="rdsp4l_31"><td id="rdsp4l_34"><p>RAM CS set</p></td><td id="rdsp4l_35"><p>RAM cell puts data onto the bus</p></td></tr></tbody></table></div><p id="rdsp4l_23">But what about writing? We'll assume some other source (the ALU, for example) writes data to a RAM cell. We'll call this our stimulus.</p><div class="table-wrapper"><table class="wide" id="rdsp4l_24"><thead><tr class="ijRowHead" id="rdsp4l_36"><th id="rdsp4l_38"><p>TQ 1</p></th><th id="rdsp4l_39"><p>TQ 2</p></th></tr></thead><tbody><tr id="rdsp4l_37"><td id="rdsp4l_40"><p>RAM CS set</p></td><td id="rdsp4l_41"><p>Stimulus writes data to bus / RAM cell reads data</p></td></tr></tbody></table></div><p id="rdsp4l_25">Oof. We're back to square one, with synchronization at the forefront of the problem. The stimulus would have to write the address and data lines during TQ0 (some time before TQ1), then the cell would route the address during TQ1 and would perform the action needed. But in reverse? The cell would have to decode the address during TQ1, then shift data out during TQ2, at which point the stimulus would have to process the data, which would once again result in an overlap.</p><p id="rdsp4l_26">In the end, I settled for a 3-TQ design. This would at least eliminate some of the headache. I'll test it later to see if I can make it more efficient.</p><div class="table-wrapper"><table class="wide" id="rdsp4l_27"><thead><tr class="ijRowHead" id="rdsp4l_42"><th id="rdsp4l_44"><p>TQ 1</p></th><th id="rdsp4l_45"><p>TQ 2</p></th><th id="rdsp4l_46"><p>TQ3</p></th></tr></thead><tbody><tr id="rdsp4l_43"><td id="rdsp4l_47"><p>Stimulus sets address</p></td><td id="rdsp4l_48"><p>Address is decoded -&gt; sync (ready) pulse emitted</p></td><td id="rdsp4l_49"><p>RAM chip reads data / writes data</p></td></tr></tbody></table></div><figure id="rdsp4l_28"><img alt="Decoder3TQ.png" src="images/Decoder3TQ.png" title="Decoder3TQ.png" width="1638" height="766"></figure><p id="rdsp4l_29">Not only does this signal look much better (it actually increments properly), you notice a &quot;parallel&quot; clock signal, pulsing on the &quot;ready&quot; line, which can be used to... [drumroll, please!] provide a clock cycle for a downstream RA(O)M cell, one where we are <span class="emphasis" id="rdsp4l_50">sure</span> that the routing is complete and data is ready. Huzzah, the decoder is ready!</p></section><div class="last-modified">Last modified: 05 January 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="1-architecture.html" class="navigation-links__prev">Architecture</a><a href="doxygen-portal.html" class="navigation-links__next">Doxygen portal</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.js"></script></body></html>